<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Text" #> 

<#
	int LEVEL = 10;
	string NameFunc = "_func";
	string NameSuffix = "_suffixes";
#>
using System;
using System.Collections.ObjectModel;
using System.Dynamic;
using System.Linq.Expressions;
using System.Reflection;

namespace Kurogane.Buildin {

public interface IKrgnFunc {
	Delegate Func { get; }
	ReadOnlyCollection<string> Suffixes { get; }
}

public static class KrgnFunc {

	public static Type GetTypeOf(int n) {
		switch(n) {
<# for (int level = 0; level < LEVEL; level++) { #>
		case <#= level #>: return typeof(<#= KlassName(level) #>);
<# } #>
		}
		throw new IndexOutOfRangeException("n must be less than <#= LEVEL #>");
	}
	
	public static ConstructorInfo GetConstructorInfo(int n) {
		switch(n) {
<# for (int level = 0; level < LEVEL; level++) { #>
		case <#= level #>: return typeof(<#= KlassName(level) #>).GetConstructor(new[] { typeof(<#= FuncOf(level) #>), typeof(string[]) });
<# } #>
		}
		throw new IndexOutOfRangeException("n must be less than <#= LEVEL #>");
	}
	
<# for (int level = 0; level < LEVEL; level++) { #>
	public static IKrgnFunc Create(<#= FuncOf(level) #> func, params string[] suffixes) {
		return new <#= KlassName(level)#>(func, suffixes);
	}
<# } #>

<# for(int level = 0; level < LEVEL; level++) { #>
private class <#= KlassName(level)#> : IKrgnFunc, IDynamicMetaObjectProvider {
	private readonly string[] <#= NameSuffix #>;
	private readonly <#= FuncOf(level) #> <#= NameFunc #>;
	
	public <#= KlassName(level) #>(<#= FuncOf(level) #> func, string[] suffixes) {
		this.<#= NameFunc #> = func;
		this.<#= NameSuffix #> = suffixes;
	}

	Delegate IKrgnFunc.Func { get { return <#= NameFunc #>; } }
	ReadOnlyCollection<string> IKrgnFunc.Suffixes {
		get { return new ReadOnlyCollection<string>(<#= NameSuffix #>); }
	}
	
	public DynamicMetaObject GetMetaObject(Expression parameter) {
		return new MetaObject(this, parameter);
	}
	
	private class MetaObject : DynamicMetaObject {
		public MetaObject(<#= KlassName(level) #> self, Expression expr)
			: base(expr, BindingRestrictions.GetTypeRestriction(expr, typeof(<#= KlassName(level) #>)), self) {
		}
		public override DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args) {
			var value = (<#= KlassName(level) #>)base.Value;
			Expression[] procArgs = new Expression[<#= level#>];
			int offset = binder.CallInfo.ArgumentCount - binder.CallInfo.ArgumentNames.Count;
<# for (int i = 0; i < level; i++) { #>
			procArgs[<#= i #>] = Expression.Convert(
				args[binder.CallInfo.ArgumentNames.IndexOf(value.<#= NameSuffix #>[<#= i #>]) + offset].Expression,
				typeof(object));
<# } #>

			Expression target = Expression.Convert(base.Expression, base.LimitType);
			Expression invokeExpr = Expression.Invoke(
				 Expression.Convert(Expression.PropertyOrField(target, "<#= NameFunc #>"), typeof(<#= FuncOf(level) #>)),
				 procArgs);
			Expression restExpr = Expression.TypeIs(base.Expression, typeof(<#= KlassName(level) #>));
			Expression suffProperty = Expression.PropertyOrField(target, "<#= NameSuffix #>");
<# for (int i = 0; i < level; i++) { #>
			restExpr = Expression.AndAlso(restExpr, Expression.Equal(
				Expression.ArrayIndex(suffProperty, Expression.Constant(<#= i #>)),
				Expression.Constant(value.<#= NameSuffix #>[<#= i #>])));
<# } #>
			var lambda = Expression.Lambda<Func<object, bool>>(restExpr, (ParameterExpression)base.Expression);
			var func = lambda.Compile();
			var result = func(value);
			return new DynamicMetaObject(invokeExpr,
				BindingRestrictions.GetExpressionRestriction(restExpr));
		}
	}
}
<# } #>
} 
} <# /* end namespace */ #>


<#+
private string KlassName(int n) {
	return "KrgnFunc" + n;
}

private string FuncOf(int n) {
	var buff = new StringBuilder();
	buff.Append("Func<");
	for(int i = 0; i < n; i++)
		buff.Append("object,");
	buff.Append("object>");
	return buff.ToString();
}
#>




